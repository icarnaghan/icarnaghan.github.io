<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding Asynchronous JavaScript | Ian Carnaghan</title>
<meta name=keywords content><meta name=description content="The term &ldquo;asynchronous&rdquo; is often associated with JavaScript, which can be a confusing concept, especially for beginners. This can become even more confusing because JavaScript is a synchronous language with asynchronous capabilities. In order to understand asynchronous development in general, we need to start with the difference between synchronous and asynchronous programming. In simple terms, executing one task or item at a time is often referred to as synchronous, while executing multiple tasks (or threads) at a time is referred to as asynchronous."><meta name=author content="icarnaghan"><link rel=canonical href=https://www.carnaghan.com/understanding-asynchronous-javascript/><meta name=google-site-verification content="G-7Q7KDW64SY"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://www.carnaghan.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://www.carnaghan.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://www.carnaghan.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://www.carnaghan.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://www.carnaghan.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.carnaghan.com/understanding-asynchronous-javascript/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q7KDW64SY"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7Q7KDW64SY")}</script><meta property="og:url" content="https://www.carnaghan.com/understanding-asynchronous-javascript/"><meta property="og:site_name" content="Ian Carnaghan"><meta property="og:title" content="Understanding Asynchronous JavaScript"><meta property="og:description" content="The term “asynchronous” is often associated with JavaScript, which can be a confusing concept, especially for beginners. This can become even more confusing because JavaScript is a synchronous language with asynchronous capabilities. In order to understand asynchronous development in general, we need to start with the difference between synchronous and asynchronous programming. In simple terms, executing one task or item at a time is often referred to as synchronous, while executing multiple tasks (or threads) at a time is referred to as asynchronous."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-11T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-11T00:00:00+00:00"><meta property="og:image" content="https://www.carnaghan.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.carnaghan.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Understanding Asynchronous JavaScript"><meta name=twitter:description content="The term &ldquo;asynchronous&rdquo; is often associated with JavaScript, which can be a confusing concept, especially for beginners. This can become even more confusing because JavaScript is a synchronous language with asynchronous capabilities. In order to understand asynchronous development in general, we need to start with the difference between synchronous and asynchronous programming. In simple terms, executing one task or item at a time is often referred to as synchronous, while executing multiple tasks (or threads) at a time is referred to as asynchronous."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.carnaghan.com/posts/"},{"@type":"ListItem","position":2,"name":"Understanding Asynchronous JavaScript","item":"https://www.carnaghan.com/understanding-asynchronous-javascript/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding Asynchronous JavaScript","name":"Understanding Asynchronous JavaScript","description":"The term \u0026ldquo;asynchronous\u0026rdquo; is often associated with JavaScript, which can be a confusing concept, especially for beginners. This can become even more confusing because JavaScript is a synchronous language with asynchronous capabilities. In order to understand asynchronous development in general, we need to start with the difference between synchronous and asynchronous programming. In simple terms, executing one task or item at a time is often referred to as synchronous, while executing multiple tasks (or threads) at a time is referred to as asynchronous.\n","keywords":[],"articleBody":"The term “asynchronous” is often associated with JavaScript, which can be a confusing concept, especially for beginners. This can become even more confusing because JavaScript is a synchronous language with asynchronous capabilities. In order to understand asynchronous development in general, we need to start with the difference between synchronous and asynchronous programming. In simple terms, executing one task or item at a time is often referred to as synchronous, while executing multiple tasks (or threads) at a time is referred to as asynchronous.\nJavaScript is synchronous, single-threaded, and blocking language. It is synchronous, meaning it can execute one statement at a time. It is single-threaded, meaning, it has a single “call stack”. We will discuss blocking later, but for now let’s take a look at how JavaScript executes code:\nfunction fun(){ console.log(\"Executed in the function\"); } console.log(\"Executed first...\"); fun(); console.log(\"Executed last...\"); It is a very simple code, but we need to dig a little bit deeper and look at execution context and the call stack. An environment where the JavaScript code is evaluated and executed is called the Execution context. There are two types of execution context in JavaScript, Global Execution Context (GEC), and Functional Execution Context (FEC). The execution contexts are stored in a stack called the call stack. There is only one call stack in JavaScript because it is a single-threaded programming language. The call stack is based on LIFO, meaning, Last In First Out. Let’s break down the above code to better understand the call stack.\n1. When the code is executed, a global execution context is created which is the first entry in the call stack.\nmain() -\u003e 2. Next, console.log(“Executed first…”) is pushed into the stack.\nmain() -\u003e console.log(\"Executed first...\") 3. After its execution is completed, it is popped out of the stack.\nmain() -\u003e 4. After that, fun() is pushed into the stack.\nmain() -\u003e fun() -\u003e 5. Now, fun() is executed. console.log(“Executed in the function”) is pushed in the stack.\nmain() -\u003e fun() -\u003e console.log(\"Executed in the function\") -\u003e 6. After the console statement is executed, it is popped out.\nmain() -\u003e fun() -\u003e 7. Function execution ends and fun() is popped out.\nmain() -\u003e 8. Next, console.log(“Executed last…”) is pushed into the stack.\nmain() -\u003e console.log(\"Executed last...\") -\u003e 9. console.log(“Executed last…”) executes and is popped out.\nmain() 10. Program execution is completed, so the main() is also removed from the stack.\nThe purpose of the above demonstration was to illustrate how JavaScript executes code line by line and only moves to the next line when the previous command has completed its execution. This is synchronous JavaScript. I also wrote an earlier article which explains the call stack in context of synchronous execution in more detail see: JavaScript Call Stack - Ian Carnaghan.\nIn the example, nothing was blocked, but there can be scenarios when the call stack is blocked due to reasons such as calling APIs, which can block the call stack. Network requests generally take time, therefore blocking the call stack:\nfunction APICall(url){ // some operation } APICall(url) console.log(\"Execution ends here...\"); In the above code, the “APIcall” function is calling an API. First, the APICall function completes execution followed by, console.log(“Execution ends here…”). Since the APICall function is making an API call, it can take some time to complete. Therefore, the execution is blocked at this point and the console statement will not run until APICall is completed. This illustrates the downside of synchronous programming. In asynchronous programming, execution would not stop. It would not wait for the APICall function to complete the execution, instead it would move further, executing the console statement. One way to achieve this is through the use of callback functions.\nCallback functions JavaScript functions are considered first-class functions. A JavaScript function can be assigned to a variable, passed to another function as a parameter, and also it can be returned from another function. You can learn more about this here.\nA function passed to another function as an argument is known as a callback function. Here’s a simple example:\nconsole.log(\"Executed first...\"); setTimeout(() =\u003e { console.log(\"Executed after 5 seconds...\"); }, 5000); console.log(\"Executed last...\"); Normally, console.log(“Executed first…”) should be executed first, followed by the setTimeout function, and finally console.log(“Executed last…”). But the above code is not synchronous, it is asynchronous. To understand this better, take a closer look at the setTimeout function.\nsetTimeout(() =\u003e { console.log(\"Executed after 5 seconds...\"); }, 5000); The first parameter of the setTimeout function is a callback function and the second parameter is 5000, meaning 5 seconds. This means, the callback function will be executed after 5 seconds. The output of the code should look like this:\nExecuted first…\nExecuted last…\nExecuted after 5 seconds…\nNotice the execution will not wait for 5 seconds, instead it will move to the next statement and execute the console command - console.log(“Executed last…”). After 5 seconds, console.log(“Executed after 5 seconds…”) will be executed. This is not synchronous nor blocking, instead it is asynchronous and non-blocking.\nThe setTimeout function waits for 5 seconds while the execution moves to the next line. After 5 seconds, the callback function of the setTimeout function is executed. This is how the callback function prevents blocking and helps in asynchronous programming.\nGoing back to the call stack again, here’s what is happening:\n1. console.log(“Executed first…”) is pushed into the stack.\nmain() -\u003e; console.log(\"Executed first...\") 2. After its execution, the console statement is popped out and the setTimeout function is pushed into the stack.\nmain() -\u003e setTimeout() The setTimeout function executes. It will wait for 5 seconds and then execute the callback function. This function is a part of the browser’s web APIs. The timer is pushed in the web API environment.\n3. In parallel, the execution of setTimeout has ended and it is popped out of the stack while the next statement - console.log(“Executed last…”) is pushed into the stack.\nmain() -\u003e console.log(\"Executed last...\") 4. After the console statement has executed, it is popped out of the stack.\nAt this point, the output is:\nExecuted first…\nExecuted last…\nMeanwhile, the timer is still going on in the web API environment and when it ends, the callback function is pushed into the “message queue”.\n5. At the point when the timer expires, the “event loop” checks the message queue if any callback exists. In our case, one callback is present in the message queue, and is pushed into the call stack.\nmain() -\u003e callback() 6. The callback executes.\nmain() -\u003e callback() -\u003e console.log(\"Executed after 5 seconds...\") 7. After the console statement is executed, it is popped out along with the callback function.\nmain() 8. In the end, the execution is completed and we have the following output.\nExecuted first…\nExecuted last…\nExecuted after 5 seconds…\nNote two important terms here - message queue and event loop.\nMessage queue: Where the callbacks are held.\nEvent loop: Checks if any callback is present in the message queue.\nNext, let’s take a look at creating our own callback function:\nfunction add(x, y, callback){ var z = x + y; callback(z); } add(10, 20, function(z){ console.log(\"Double of z:\", z * 2) }) The “add” function has three arguments - x, y, and a callback function. The sum of x and y is calculated in the add function and then, it is passed to the callback function. We can also break out the above code this way:\nfunction double(z){ console.log(\"Double of z:\", z * 2) } function add(x, y, callback){ var z = x + y; callback(z); } add(10, 20, double); Instead of passing an anonymous function, here we just create a separate function.\nCallback hell Using callback functions is a way to develop synchronously, but overuse can result in what has commonly been coined as callback hell. This is a situation when too many nested callbacks are used.\nconst userVerification = function(uname, pword, callback){ db.userVerification(uname, pword, (err, info) =\u003e{ if(err){ callback(err) } else{\tdb.fetchRoles(uname, (err, roles) =\u003e{\tif(err) { callback(err) } else{ callback(null, info, roles) } } } } } As you can probably tell, the code above is complicated. First, the “userVerification” method is called for “info, next the “fetchRoles” method is called for “roles”. As these are database operations, they can take some time to complete, therefore we are leveraging asynchronous programming. It’s apparent that this could quickly get more complex, for example, if there needed to be more callbacks in the “userVerification” and “fetchRoles” functions. Many nested callbacks will cause problems in terms of complexity and maintainability of your code. To avoid the callback hell, there are two alternatives available to us in JavaScript, promises and async/await.\nPromise Promises, just like in real life, are either fulfilled or broken. Promises in JavaScript work similarly. Let’s explore this further through an example. Sam’s birthday is January 10th, and today is January 1st. Sam’s father made a promise that he will buy Sam a brand new iPhone on his birthday which is 10 days later. From January 1st to the 9th, the promise made by Sam’s father is pending. Only on January 10th will Sam find out if the promise that his father made will be fulfilled. There can be two scenarios: Sam’s father fulfills the promise and Sam gets a brand new iPhone, or Sam’s father breaks the promise. Promises work similarly in JavaScript. A promise in JavaScript has three possible states - pending, fulfilled, and rejected.\nconst promise = new Promise((resolve, reject) =\u003e { }) A promise is created using the new keyword and Promise method. The Promise method has a callback as its parameter. The callback function, in turn, has two parameters, resolve and reject. Let’s take a closer look with a working example below.\nResolving a promise Let’s assume that we have three functions in a program: add, double, and display. The add function returns the sum of two numbers in 5 seconds, the double function returns the double value of the sum in 3 seconds, and the display function returns the final message in 2 seconds. This is asynchronous but instead of using callback functions we are using promises.\nconst add = (x, y) =\u003e{ return new Promise((resolve,reject) =\u003e { setTimeout(() =\u003e{ resolve(x + y) }, 5000 ) })\t} console.log(add(10, 20)); The add function returns a promise, which has a setTimeout function.\nconst add = (x, y) =\u003e{ console.log(\"Wait for 5 seconds...\") return new Promise((resolve,reject) =\u003e setTimeout(() =\u003e{ resolve(x + y) }, 5000 ) })\t} add(10, 20).then( value =\u003e { console.log(value); }) The then method is attached with the add function, which also has a callback function as the parameter. The promise returned by the add function is pending, and when it finishes (the timer of the setTimeout function ends), the promise is resolved. The then method is used to handle the promise.\nThe parameter of the then method is nothing but the value we passed to the resolve function earlier in the setTimeout function.\nconst display = (q) =\u003e{ console.log(\"Wait for 2 seconds...\") return new Promise((resolve,reject) =\u003e { setTimeout(() =\u003e{ resolve(\"The final value is: \" + q) }, 2000 ) })\t} const double = (z) =\u003e{ console.log(\"Wait for 3 seconds...\") return new Promise((resolve,reject) =\u003e { setTimeout(() =\u003e{ resolve(z * 2) }, 3000 ) })\t} const add = (x, y) =\u003e{ console.log(\"Wait for 5 seconds...\") return new Promise((resolve,reject) =\u003e { setTimeout(() =\u003e{ resolve(x + y) }, 5000 )\t})\t} add(10, 20).then( value1 =\u003e { double(value1).then( value2 =\u003e{ display(value2).then( value3 =\u003e{ console.log(value3) }) }) }) The above code is the complete example discussed earlier. Let’s break this down:\nadd(10, 20).then( value1 =\u003e { In this line, the add function is called and it returns the sum of 10 and 20 in 5 seconds. “value1” is the sum of 10 and 20.\nadd(10, 20).then( value1 =\u003e { double(value1).then( value2 =\u003e{ After waiting for 5 seconds, we have the sum, so we passed it to the double function. “value2” is returned by the double function after 3 seconds.\nadd(10, 20).then( value1 =\u003e { double(value1).then( value2 =\u003e{ display(value2).then( value3 =\u003e{ Next, after waiting 2 seconds, we have the double value, which we passed to the display function. “value3” is returned by the display function after 2 seconds.\nadd(10, 20).then( value1 =\u003e { double(value1).then( value2 =\u003e{ display(value2).then( value3 =\u003e{ console.log(value3) }) }) }) Finally, “value3” is printed in the console.\nRejecting a promise Let’s assume we do not want to add the number if they are equal. In this situation, we would have to reject the promise. In order to do this, we can attach what is known as a “catch” method.\nconst add = (x, y) =\u003e{ return new Promise((resolve,reject) =\u003e { if(x != y){ setTimeout(() =\u003e{ resolve(x + y) }, 5000 ) } else{ reject(\"x and y are equal!\") } })\t} add(10, 10).then( value1 =\u003e { console.log(value1); }) .catch(err =\u003e { console.log(err); }) The promise is rejected when x is equal to y, therefore we have a catch method attached directly after the add statement. The catch method has a callback function as its parameter and the callback function, in turn, has a parameter, i.e. error which is displayed in the console.\nAsync/await Working with promises is complicated. In a real application, you would be handling multiple API calls, whereby several mechanisms would be in place to work with data and potentially multiple external sources. Due to its complexity, the concept of async/await was revealed with ECMAScript 2017.\nAsync/await is an approach that uses promises in a better and more simplistic way. These are essentially keywords that help us synchronously write promise-based code, without blocking the main thread. In other words, we can write asynchronous code as it was synchronous, greatly simplifying the development process.\nA function declared with the “async” keyword is an async function that returns a promise. It does not matter what an async function is returning, it will always be a promise. Let’s take a look at some examples.\nasync function add(x, y){ return x + y } console.log(add(10,20)) “add” is an async function. It returns the sum of x and y.\nThis function returns a promise, but we only return the sum of x and y. With async, we can simply use the then method to unwrap the promise.\nasync function add(x, y){ return x + y;\t} add(10,20).then( value =\u003e { console.log(value); //30 }) We can clearly see the difference async functions can make. Next, we’re going to look at await, but before we do that let’s take a look at the add function below.\nconst add = (x, y) =\u003e{ console.log(\"Wait for 5 seconds...\") return new Promise((resolve,reject) =\u003e { setTimeout(() =\u003e{ resolve(x + y) }, 5000 ) })\t} add(10, 20).then( value =\u003e { console.log(value); }) In order to demonstrate async/await, let’s modify the above code.\nThe await keyword will help us reduce the complexity of the code. This keyword holds the JavaScript execution until the promise is settled.\nfunction add(x, y){ const pr = new Promise((resolve,reject) =\u003e { setTimeout(() =\u003e{ resolve(x + y) }, 5000 ) })\tconst sum = await pr; console.log(\"Sum of x and y:\", sum); } In this function, a promise (pr) is created.\nconst sum = await pr; The execution will halt at this point without blocking the main thread. But we cannot use “await” in a normal function, it needs to be in an async function. The nice thing here is that we do not need the “then” method to unwrap the promise. The “await” keyword essentially handles everything for us!\nasync function add(x, y){ const pr = new Promise((resolve,reject) =\u003e { setTimeout(() =\u003e{ resolve(x + y) }, 5000 ) })\tconsole.log(\"Waiting for 5 seconds...\"); const sum = await pr; console.log(\"Sum of x and y:\", sum); } add(10, 20) Executing this code results in the following:\nTo conclude, this is how we can use async/await as the alternative to the traditional promise approach.\nConclusion In this article, we covered everything regarding asynchronous JavaScript, starting from synchronous and asynchronous programming, how to handle asynchronous using callbacks, discussing callback hell and how to counter this using promises, and finally, the alternative to promises - async/await. If are a JavaScript developer working with Node.js, understanding asynchronous JavaScript is essential. Hopefully you have gained an understanding of how JavaScript can support both synchronous and asynchronous programming, the execution context, call stack, message queue, and event loop. These are topics that are generally glossed over, but are essential to gaining a deeper knowledge of JavaScript development.\nFor more on Asynchronous development with JavaScript, see: Asynchronous Programming :: Eloquent JavaScript\n","wordCount":"2748","inLanguage":"en","image":"https://www.carnaghan.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2020-09-11T00:00:00Z","dateModified":"2020-09-11T00:00:00Z","author":{"@type":"Person","name":"icarnaghan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.carnaghan.com/understanding-asynchronous-javascript/"},"publisher":{"@type":"Organization","name":"Ian Carnaghan","logo":{"@type":"ImageObject","url":"https://www.carnaghan.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.carnaghan.com/ accesskey=h title="Ian Carnaghan (Alt + H)"><img src=https://www.carnaghan.com/apple-touch-icon.png alt aria-label=logo height=35>Ian Carnaghan</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.carnaghan.com/about-me/ title="About Me"><span>About Me</span></a></li><li><a href=https://www.carnaghan.com/categories/coding/ title=Coding><span>Coding</span></a></li><li><a href=https://www.carnaghan.com/bitesize-javascript/ title="Bitesize JavaScript"><span>Bitesize JavaScript</span></a></li><li><a href=https://www.carnaghan.com/categories/data-analytics/ title="Data Analytics"><span>Data Analytics</span></a></li><li><a href=https://www.carnaghan.com/categories/cybersecurity/ title=Cybersecurity><span>Cybersecurity</span></a></li><li><a href=https://www.carnaghan.com/categories/ux-design/ title="UX and Design"><span>UX and Design</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.carnaghan.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.carnaghan.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Understanding Asynchronous JavaScript</h1><div class=post-meta><span title='2020-09-11 00:00:00 +0000 UTC'>September 11, 2020</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2748 words&nbsp;·&nbsp;icarnaghan&nbsp;|&nbsp;<a href=https://github.com/icarnaghan/carnaghan.com/tree/main/content/posts/understanding-asynchronous-javascript/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>The term &ldquo;asynchronous&rdquo; is often associated with JavaScript, which can be a confusing concept, especially for beginners. This can become even more confusing because JavaScript is a synchronous language with asynchronous capabilities. In order to understand asynchronous development in general, we need to start with the difference between synchronous and asynchronous programming. In simple terms, executing one task or item at a time is often referred to as synchronous, while executing multiple tasks (or threads) at a time is referred to as asynchronous.</p><p>JavaScript is synchronous, single-threaded, and blocking language. It is synchronous, meaning it can execute one statement at a time. It is single-threaded, meaning, it has a single &ldquo;call stack&rdquo;. We will discuss blocking later, but for now let&rsquo;s take a look at how JavaScript executes code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>fun</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed in the function&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed first...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed last...&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>It is a very simple code, but we need to dig a little bit deeper and look at execution context and the call stack. An environment where the JavaScript code is evaluated and executed is called the Execution context. There are two types of execution context in JavaScript, Global Execution Context (GEC), and Functional Execution Context (FEC). The execution contexts are stored in a stack called the call stack. There is only one call stack in JavaScript because it is a single-threaded programming language. The call stack is based on LIFO, meaning, Last In First Out. Let&rsquo;s break down the above code to better understand the call stack.</p><p>1. When the code is executed, a global execution context is created which is the first entry in the call stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span></code></pre></div><p>2. Next, console.log(&ldquo;Executed first&mldr;&rdquo;) is pushed into the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed first...&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>3. After its execution is completed, it is popped out of the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span></code></pre></div><p>4. After that, fun() is pushed into the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>fun</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span></code></pre></div><p>5. Now, fun() is executed. console.log(&ldquo;Executed in the function&rdquo;) is pushed in the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>fun</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed in the function&#34;</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span></code></pre></div><p>6. After the console statement is executed, it is popped out.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>fun</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span></code></pre></div><p>7. Function execution ends and fun() is popped out.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span>
</span></span></code></pre></div><p>8. Next, console.log(&ldquo;Executed last&mldr;&rdquo;) is pushed into the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed last...&#34;</span><span class=p>)</span> <span class=o>-&gt;</span>
</span></span></code></pre></div><p>9. console.log(&ldquo;Executed last&mldr;&rdquo;) executes and is popped out.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> 
</span></span></code></pre></div><p>10. Program execution is completed, so the main() is also removed from the stack.</p><p>The purpose of the above demonstration was to illustrate how JavaScript executes code line by line and only moves to the next line when the previous command has completed its execution. This is synchronous JavaScript. I also wrote an earlier article which explains the call stack in context of synchronous execution in more detail see: JavaScript Call Stack - Ian Carnaghan.</p><p>In the example, nothing was blocked, but there can be scenarios when the call stack is blocked due to reasons such as calling APIs, which can block the call stack. Network requests generally take time, therefore blocking the call stack:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>APICall</span><span class=p>(</span><span class=nx>url</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// some operation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>APICall</span><span class=p>(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Execution ends here...&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>In the above code, the &ldquo;APIcall&rdquo; function is calling an API. First, the APICall function completes execution followed by, console.log(&ldquo;Execution ends here&mldr;&rdquo;). Since the APICall function is making an API call, it can take some time to complete. Therefore, the execution is blocked at this point and the console statement will not run until APICall is completed. This illustrates the downside of synchronous programming. In asynchronous programming, execution would not stop. It would not wait for the APICall function to complete the execution, instead it would move further, executing the console statement. One way to achieve this is through the use of callback functions.</p><h2 id=callback-functions>Callback functions<a hidden class=anchor aria-hidden=true href=#callback-functions>#</a></h2><p>JavaScript functions are considered first-class functions. A JavaScript function can be assigned to a variable, passed to another function as a parameter, and also it can be returned from another function. You can learn more about this here.</p><p>A function passed to another function as an argument is known as a callback function. Here&rsquo;s a simple example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed first...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed after 5 seconds...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=mi>5000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed last...&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Normally, console.log(&ldquo;Executed first&mldr;&rdquo;) should be executed first, followed by the setTimeout function, and finally console.log(&ldquo;Executed last&mldr;&rdquo;). But the above code is not synchronous, it is asynchronous. To understand this better, take a closer look at the setTimeout function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed after 5 seconds...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>5000</span><span class=p>);</span>
</span></span></code></pre></div><p>The first parameter of the setTimeout function is a callback function and the second parameter is 5000, meaning 5 seconds. This means, the callback function will be executed after 5 seconds. The output of the code should look like this:</p><ul><li><p>Executed first&mldr;</p></li><li><p>Executed last&mldr;</p></li><li><p>Executed after 5 seconds&mldr;</p></li></ul><p>Notice the execution will not wait for 5 seconds, instead it will move to the next statement and execute the console command - console.log(&ldquo;Executed last&mldr;&rdquo;). After 5 seconds, console.log(&ldquo;Executed after 5 seconds&mldr;&rdquo;) will be executed. This is not synchronous nor blocking, instead it is asynchronous and non-blocking.</p><p>The setTimeout function waits for 5 seconds while the execution moves to the next line. After 5 seconds, the callback function of the setTimeout function is executed. This is how the callback function prevents blocking and helps in asynchronous programming.</p><p>Going back to the call stack again, here&rsquo;s what is happening:</p><p>1. <strong>console.log(&ldquo;Executed first&mldr;&rdquo;)</strong> is pushed into the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span><span class=p>;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed first...&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>2. After its execution, the console statement is popped out and the setTimeout function is pushed into the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>setTimeout</span><span class=p>()</span>
</span></span></code></pre></div><p>The setTimeout function executes. It will wait for 5 seconds and then execute the callback function. This function is a part of the browser&rsquo;s web APIs. The timer is pushed in the web API environment.</p><p>3. In parallel, the execution of setTimeout has ended and it is popped out of the stack while the next statement - console.log(&ldquo;Executed last&mldr;&rdquo;) is pushed into the stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed last...&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>4. After the console statement has executed, it is popped out of the stack.</p><p>At this point, the output is:</p><ul><li><p>Executed first&mldr;</p></li><li><p>Executed last&mldr;</p></li></ul><p>Meanwhile, the timer is still going on in the web API environment and when it ends, the callback function is pushed into the &ldquo;message queue&rdquo;.</p><p>5. At the point when the timer expires, the &ldquo;event loop&rdquo; checks the message queue if any callback exists. In our case, one callback is present in the message queue, and is pushed into the call stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>callback</span><span class=p>()</span>
</span></span></code></pre></div><p>6. The callback executes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>callback</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Executed after 5 seconds...&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>7. After the console statement is executed, it is popped out along with the callback function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>main</span><span class=p>()</span>
</span></span></code></pre></div><p>8. In the end, the execution is completed and we have the following output.</p><ul><li><p>Executed first&mldr;</p></li><li><p>Executed last&mldr;</p></li><li><p>Executed after 5 seconds&mldr;</p></li></ul><p>Note two important terms here - message queue and event loop.</p><ul><li><p>Message queue: Where the callbacks are held.</p></li><li><p>Event loop: Checks if any callback is present in the message queue.</p></li></ul><p>Next, let&rsquo;s take a look at creating our own callback function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>callback</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>z</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>callback</span><span class=p>(</span><span class=nx>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=kd>function</span><span class=p>(</span><span class=nx>z</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Double of z:&#34;</span><span class=p>,</span> <span class=nx>z</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>The &ldquo;add&rdquo; function has three arguments - x, y, and a callback function. The sum of x and y is calculated in the add function and then, it is passed to the callback function. We can also break out the above code this way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=kr>double</span><span class=p>(</span><span class=nx>z</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Double of z:&#34;</span><span class=p>,</span> <span class=nx>z</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>callback</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>z</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nx>callback</span><span class=p>(</span><span class=nx>z</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=kr>double</span><span class=p>);</span>
</span></span></code></pre></div><p>Instead of passing an anonymous function, here we just create a separate function.</p><h2 id=callback-hell>Callback hell<a hidden class=anchor aria-hidden=true href=#callback-hell>#</a></h2><p>Using callback functions is a way to develop synchronously, but overuse can result in what has commonly been coined as callback hell. This is a situation when too many nested callbacks are used.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>userVerification</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>uname</span><span class=p>,</span> <span class=nx>pword</span><span class=p>,</span> <span class=nx>callback</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nx>db</span><span class=p>.</span><span class=nx>userVerification</span><span class=p>(</span><span class=nx>uname</span><span class=p>,</span> <span class=nx>pword</span><span class=p>,</span> <span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>info</span><span class=p>)</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nx>err</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=nx>callback</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=p>{</span>	
</span></span><span class=line><span class=cl>	    <span class=nx>db</span><span class=p>.</span><span class=nx>fetchRoles</span><span class=p>(</span><span class=nx>uname</span><span class=p>,</span> <span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>roles</span><span class=p>)</span> <span class=p>=&gt;{</span>	
</span></span><span class=line><span class=cl>	        <span class=k>if</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		    <span class=nx>callback</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		    <span class=nx>callback</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span> <span class=nx>info</span><span class=p>,</span> <span class=nx>roles</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As you can probably tell, the code above is complicated. First, the &ldquo;userVerification&rdquo; method is called for &ldquo;info, next the &ldquo;fetchRoles&rdquo; method is called for &ldquo;roles&rdquo;. As these are database operations, they can take some time to complete, therefore we are leveraging asynchronous programming. It&rsquo;s apparent that this could quickly get more complex, for example, if there needed to be more callbacks in the &ldquo;userVerification&rdquo; and &ldquo;fetchRoles&rdquo; functions. Many nested callbacks will cause problems in terms of complexity and maintainability of your code. To avoid the callback hell, there are two alternatives available to us in JavaScript, promises and async/await.</p><h2 id=promise>Promise<a hidden class=anchor aria-hidden=true href=#promise>#</a></h2><p>Promises, just like in real life, are either fulfilled or broken. Promises in JavaScript work similarly. Let&rsquo;s explore this further through an example. Sam&rsquo;s birthday is January 10th, and today is January 1st. Sam&rsquo;s father made a promise that he will buy Sam a brand new iPhone on his birthday which is 10 days later. From January 1st to the 9th, the promise made by Sam&rsquo;s father is pending. Only on January 10th will Sam find out if the promise that his father made will be fulfilled. There can be two scenarios: Sam&rsquo;s father fulfills the promise and Sam gets a brand new iPhone, or Sam&rsquo;s father breaks the promise. Promises work similarly in JavaScript. A promise in JavaScript has three possible states - pending, fulfilled, and rejected.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>A promise is created using the new keyword and Promise method. The Promise method has a callback as its parameter. The callback function, in turn, has two parameters, resolve and reject. Let&rsquo;s take a closer look with a working example below.</p><h2 id=resolving-a-promise>Resolving a promise<a hidden class=anchor aria-hidden=true href=#resolving-a-promise>#</a></h2><p>Let&rsquo;s assume that we have three functions in a program: add, double, and display. The add function returns the sum of two numbers in 5 seconds, the double function returns the double value of the sum in 3 seconds, and the display function returns the final message in 2 seconds. This is asynchronous but instead of using callback functions we are using promises.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>add</span> <span class=o>=</span> <span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>            <span class=nx>resolve</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span> <span class=mi>5000</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>		
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>));</span>
</span></span></code></pre></div><p>The add function returns a promise, which has a setTimeout function.</p><p><img alt=Promise loading=lazy src=/understanding-asynchronous-javascript/images/promise1.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>add</span> <span class=o>=</span> <span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Wait for 5 seconds...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> 
</span></span><span class=line><span class=cl>        <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nx>resolve</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span> <span class=mi>5000</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>		
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>The <strong>then</strong> method is attached with the add function, which also has a callback function as the parameter. The promise returned by the add function is pending, and when it finishes (the timer of the setTimeout function ends), the promise is resolved. The then method is used to handle the promise.</p><p><img alt="Promise wait" loading=lazy src=/understanding-asynchronous-javascript/images/promise2.png></p><p>The parameter of the then method is nothing but the value we passed to the resolve function earlier in the setTimeout function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>display</span> <span class=o>=</span> <span class=p>(</span><span class=nx>q</span><span class=p>)</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Wait for 2 seconds...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>            <span class=nx>resolve</span><span class=p>(</span><span class=s2>&#34;The final value is: &#34;</span> <span class=o>+</span> <span class=nx>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span> <span class=mi>2000</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>		
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=kr>double</span> <span class=o>=</span> <span class=p>(</span><span class=nx>z</span><span class=p>)</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Wait for 3 seconds...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>            <span class=nx>resolve</span><span class=p>(</span><span class=nx>z</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span> <span class=mi>3000</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>		
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>add</span> <span class=o>=</span> <span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Wait for 5 seconds...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>            <span class=nx>resolve</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span> <span class=mi>5000</span> <span class=p>)</span>	
</span></span><span class=line><span class=cl>    <span class=p>})</span>		
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value1</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>double</span><span class=p>(</span><span class=nx>value1</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value2</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>display</span><span class=p>(</span><span class=nx>value2</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value3</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>The above code is the complete example discussed earlier. Let&rsquo;s break this down:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value1</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span></code></pre></div><p>In this line, the add function is called and it returns the sum of 10 and 20 in 5 seconds. &ldquo;value1&rdquo; is the sum of 10 and 20.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value1</span> <span class=p>=&gt;</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=kr>double</span><span class=p>(</span><span class=nx>value1</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value2</span> <span class=p>=&gt;{</span>
</span></span></code></pre></div><p>After waiting for 5 seconds, we have the sum, so we passed it to the double function. &ldquo;value2&rdquo; is returned by the double function after 3 seconds.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value1</span> <span class=p>=&gt;</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=kr>double</span><span class=p>(</span><span class=nx>value1</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value2</span> <span class=p>=&gt;{</span> 
</span></span><span class=line><span class=cl>        <span class=nx>display</span><span class=p>(</span><span class=nx>value2</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value3</span> <span class=p>=&gt;{</span>
</span></span></code></pre></div><p>Next, after waiting 2 seconds, we have the double value, which we passed to the display function. &ldquo;value3&rdquo; is returned by the display function after 2 seconds.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value1</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>double</span><span class=p>(</span><span class=nx>value1</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value2</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>        <span class=nx>display</span><span class=p>(</span><span class=nx>value2</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value3</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>Finally, &ldquo;value3&rdquo; is printed in the console.</p><p><img alt="Promise 3" loading=lazy src=/understanding-asynchronous-javascript/images/promise3.png></p><h2 id=rejecting-a-promise>Rejecting a promise<a hidden class=anchor aria-hidden=true href=#rejecting-a-promise>#</a></h2><p>Let&rsquo;s assume we do not want to add the number if they are equal. In this situation, we would have to reject the promise. In order to do this, we can attach what is known as a &ldquo;catch&rdquo; method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>add</span> <span class=o>=</span> <span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nx>x</span> <span class=o>!=</span> <span class=nx>y</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>                <span class=nx>resolve</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span> <span class=mi>5000</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>reject</span><span class=p>(</span><span class=s2>&#34;x and y are equal!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>		
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value1</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=k>catch</span><span class=p>(</span><span class=nx>err</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>err</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>The promise is rejected when x is equal to y, therefore we have a catch method attached directly after the add statement. The catch method has a callback function as its parameter and the callback function, in turn, has a parameter, i.e. error which is displayed in the console.</p><p><img alt="Promise 4" loading=lazy src=/understanding-asynchronous-javascript/images/promise4.png></p><h2 id=asyncawait>Async/await<a hidden class=anchor aria-hidden=true href=#asyncawait>#</a></h2><p>Working with promises is complicated. In a real application, you would be handling multiple API calls, whereby several mechanisms would be in place to work with data and potentially multiple external sources. Due to its complexity, the concept of async/await was revealed with ECMAScript 2017.</p><p>Async/await is an approach that uses promises in a better and more simplistic way. These are essentially keywords that help us synchronously write promise-based code, without blocking the main thread. In other words, we can write asynchronous code as it was synchronous, greatly simplifying the development process.</p><p>A function declared with the &ldquo;async&rdquo; keyword is an async function that returns a promise. It does not matter what an async function is returning, it will always be a promise. Let&rsquo;s take a look at some examples.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>20</span><span class=p>))</span>
</span></span></code></pre></div><p>&ldquo;add&rdquo; is an async function. It returns the sum of x and y.</p><p><img alt="Async 1" loading=lazy src=/understanding-asynchronous-javascript/images/async1.png></p><p>This function returns a promise, but we only return the sum of x and y. With async, we can simply use the <strong>then</strong> method to unwrap the promise.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>;</span>	
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>20</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>);</span> <span class=c1>//30
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>})</span>
</span></span></code></pre></div><p>We can clearly see the difference async functions can make. Next, we&rsquo;re going to look at await, but before we do that let&rsquo;s take a look at the <strong>add</strong> function below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>add</span> <span class=o>=</span> <span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Wait for 5 seconds...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>resolve</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>5000</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>})</span>		
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span> <span class=nx>value</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>In order to demonstrate async/await, let&rsquo;s modify the above code.</p><p>The <strong>await</strong> keyword will help us reduce the complexity of the code. This keyword holds the JavaScript execution until the promise is settled.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>pr</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>            <span class=nx>resolve</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span> <span class=mi>5000</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>	
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>sum</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>pr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Sum of x and y:&#34;</span><span class=p>,</span> <span class=nx>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this function, a promise (pr) is created.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sum</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>pr</span><span class=p>;</span>
</span></span></code></pre></div><p>The execution will halt at this point without blocking the main thread. But we cannot use &ldquo;await&rdquo; in a normal function, it needs to be in an async function. The nice thing here is that we do not need the &ldquo;then&rdquo; method to unwrap the promise. The &ldquo;await&rdquo; keyword essentially handles everything for us!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>pr</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span><span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;{</span>
</span></span><span class=line><span class=cl>            <span class=nx>resolve</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span> <span class=mi>5000</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>	
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Waiting for 5 seconds...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>sum</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>pr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Sum of x and y:&#34;</span><span class=p>,</span> <span class=nx>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span>
</span></span></code></pre></div><p>Executing this code results in the following:</p><p><img alt="Async 2" loading=lazy src=/understanding-asynchronous-javascript/images/async2.png></p><p>To conclude, this is how we can use async/await as the alternative to the traditional promise approach.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In this article, we covered everything regarding asynchronous JavaScript, starting from synchronous and asynchronous programming, how to handle asynchronous using callbacks, discussing callback hell and how to counter this using promises, and finally, the alternative to promises - async/await. If are a JavaScript developer working with Node.js, understanding asynchronous JavaScript is essential. Hopefully you have gained an understanding of how JavaScript can support both synchronous and asynchronous programming, the execution context, call stack, message queue, and event loop. These are topics that are generally glossed over, but are essential to gaining a deeper knowledge of JavaScript development.</p><p>For more on Asynchronous development with JavaScript, see: Asynchronous Programming :: Eloquent JavaScript</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.carnaghan.com/low-code-development-with-opentext-appworks/><span class=title>« Prev</span><br><span>Low-Code Development with OpenText AppWorks</span>
</a><a class=next href=https://www.carnaghan.com/understanding-higher-order-functions-in-javascript/><span class=title>Next »</span><br><span>Understanding Higher Order Functions in JavaScript</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Asynchronous JavaScript on x" href="https://x.com/intent/tweet/?text=Understanding%20Asynchronous%20JavaScript&amp;url=https%3a%2f%2fwww.carnaghan.com%2funderstanding-asynchronous-javascript%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Asynchronous JavaScript on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.carnaghan.com%2funderstanding-asynchronous-javascript%2f&amp;title=Understanding%20Asynchronous%20JavaScript&amp;summary=Understanding%20Asynchronous%20JavaScript&amp;source=https%3a%2f%2fwww.carnaghan.com%2funderstanding-asynchronous-javascript%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Asynchronous JavaScript on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.carnaghan.com%2funderstanding-asynchronous-javascript%2f&title=Understanding%20Asynchronous%20JavaScript"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Asynchronous JavaScript on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.carnaghan.com%2funderstanding-asynchronous-javascript%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Asynchronous JavaScript on whatsapp" href="https://api.whatsapp.com/send?text=Understanding%20Asynchronous%20JavaScript%20-%20https%3a%2f%2fwww.carnaghan.com%2funderstanding-asynchronous-javascript%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Asynchronous JavaScript on telegram" href="https://telegram.me/share/url?text=Understanding%20Asynchronous%20JavaScript&amp;url=https%3a%2f%2fwww.carnaghan.com%2funderstanding-asynchronous-javascript%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Asynchronous JavaScript on ycombinator" href="https://news.ycombinator.com/submitlink?t=Understanding%20Asynchronous%20JavaScript&u=https%3a%2f%2fwww.carnaghan.com%2funderstanding-asynchronous-javascript%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//carnaghan.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.carnaghan.com/>Ian Carnaghan</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>